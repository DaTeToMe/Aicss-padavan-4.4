#!/bin/sh

modprobe xt_TPROXY
modprobe xt_set
TAG="SS_SPEC_"
ipt_n="iptables -t nat"
ipt_m="iptables -t mangle"
FWI=/tmp/shadowsocks_iptables.save
ADNU=$(iptables -t nat -L  PREROUTING -n --line-number | grep "ADBYBY" |cut -c1-1)
SSNU=$(($ADNU+1))

# 优化1：预定义常用的私有IP段，避免重复定义
PRIVATE_NETWORKS="0.0.0.0/8 10.0.0.0/8 127.0.0.0/8 169.254.0.0/16 172.16.0.0/12 192.168.0.0/16 224.0.0.0/4 240.0.0.0/4"

# 优化2：当需要时才读取配置文件内容，避免不必要的I/O

usage() {
	cat <<-EOF
		Usage: ssr-rules [options]

		Valid options are:

		    -s <server_ip>          ip address of shadowsocksr remote server
		    -l <local_port>         port number of shadowsocksr local server
		    -S <server_ip>          ip address of shadowsocksr remote UDP server
		    -L <local_port>         port number of shadowsocksr local UDP server
		    -i <ip_list_file>       a file content is bypassed ip list
		    -a <lan_ips>            lan ip of access control, need a prefix to
		                            define access control mode
		    -b <wan_ips>            wan ip of will be bypassed
		    -w <wan_ips>            wan ip of will be forwarded
		    -p <fp_lan_ips>         lan ip of will be global proxy
		    -G <gm_lan_ips>         lan ip of will be game mode proxy
		    -D <proxy_ports>        proxy ports
		    -e <extra_options>      extra options for iptables
		    -o                      apply the rules to the OUTPUT chain
		    -O                      apply the global rules to the OUTPUT chain
		    -u                      enable udprelay mode, TPROXY is required
		    -U                      enable udprelay mode, using different IP
		                            and ports for TCP and UDP
		    -f                      flush the rules
		    -g                      gfw list mode
		    -r                      return china mode
		    -k
		    -h                      show this help message and exit
EOF
	exit $1
}

loger() {
	logger -st ss-rules[$$] -p$1 $2
}

# 优化3：IPv4地址验证函数
valid_ipv4() {
	echo "$1" | grep -E "^([0-9]{1,3}\.){3}[0-9]{1,3}(/[0-9]{1,2})?$" >/dev/null
}

# 优化4：统一的表清理函数，避免重复代码
flush_table() {
	local table="$1"
	local ipt="iptables -t $table"
	local DAT=$(iptables-save -t $table)
	
	# 删除包含TAG的规则
	echo "$DAT" | grep "$TAG" | sed -e 's/^-A/$ipt -D/' -e 's/$/;/' | sh 2>/dev/null
	
	# 删除自定义链
	for chain in $(echo "$DAT" | awk '/^:SS_SPEC/{print $1}'); do
		$ipt -F ${chain:1} 2>/dev/null && $ipt -X ${chain:1} 2>/dev/null
	done
}

flush_r() {
	sed -i '/dnsmasq.dom/d' /etc/storage/dnsmasq/dnsmasq.conf
	
	# 优化5：并行清理不同表
	{
		flush_table nat &
		flush_table mangle &
		wait
	}
	
	# 优化6：批量清理路由和ipset
	{
		ip rule del fwmark 0x01/0x01 table 100 2>/dev/null
		ip route del local 0.0.0.0/0 dev lo table 100 2>/dev/null
	} &
	
	# 优化7：批量删除ipset，忽略错误
	for ipset_name in ss_spec_lan_ac ss_spec_wan_ac ssr_gen_router china fplan gmlan gfwlist oversea blacklist whitelist; do
		ipset -X $ipset_name 2>/dev/null &
	done
	wait
	
	[ -n "$FWI" ] && echo '#!/bin/sh' >$FWI
	return 0
}

# 优化8：批量创建ipset的函数
create_ipsets() {
	# 优化：使用批量ipset命令减少系统调用
	ipset -exist restore <<-EOF
	create china hash:net family inet
	create gmlan hash:net family inet
	create gfwlist hash:net family inet
	create whitelist hash:net family inet
	create blacklist hash:net family inet
	create fplan hash:net family inet
	create oversea hash:net family inet
EOF
}

# 优化9：批量添加IP到ipset
batch_add_ips_to_ipset() {
	local ipset_name="$1"
	local ip_list="$2"
	
	# 优化：构建批量添加命令
	local batch_cmd=""
	for ip in $ip_list; do
		if valid_ipv4 "$ip"; then
			batch_cmd="${batch_cmd}add $ipset_name $ip
"
		fi
	done
	
	# 优化：一次性执行所有添加操作
	if [ -n "$batch_cmd" ]; then
		echo "$batch_cmd" | ipset -exist restore
	fi
}

# 优化10：运行模式规则生成器
generate_mode_rules() {
	local mode="$1"
	local rules=""
	
	case "$mode" in
	router)
		rules="$ipt_n -A SS_SPEC_WAN_AC -m set --match-set ss_spec_wan_ac dst -j RETURN
$ipt_n -A SS_SPEC_WAN_AC -m set --match-set china dst -j RETURN
$ipt_n -A SS_SPEC_WAN_AC -m set --match-set gfwlist dst -j SS_SPEC_WAN_FW
$ipt_n -A SS_SPEC_WAN_AC -m set --match-set gmlan src -m set ! --match-set china dst -j SS_SPEC_WAN_FW
$ipt_n -A SS_SPEC_WAN_AC -j SS_SPEC_WAN_FW"
		;;
	gfw)
		rules="$ipt_n -A SS_SPEC_WAN_AC -m set --match-set china dst -j RETURN
$ipt_n -A SS_SPEC_WAN_AC -m set --match-set gfwlist dst -j SS_SPEC_WAN_FW
$ipt_n -A SS_SPEC_WAN_AC -m set --match-set gmlan src -m set ! --match-set china dst -j SS_SPEC_WAN_FW
$ipt_n -A SS_SPEC_WAN_AC -j SS_SPEC_WAN_FW"
		;;
	oversea)
		rules="$ipt_n -A SS_SPEC_WAN_AC -m set --match-set oversea dst -j SS_SPEC_WAN_FW
$ipt_n -A SS_SPEC_WAN_AC -m set --match-set gmlan src -j SS_SPEC_WAN_FW
$ipt_n -A SS_SPEC_WAN_AC -m set --match-set china dst -j SS_SPEC_WAN_FW"
		;;
	all)
		rules="$ipt_n -A SS_SPEC_WAN_AC -j SS_SPEC_WAN_FW"
		;;
	esac
	
	echo "$rules"
}

ipset_r() {
	mkdir -p /tmp/dnsmasq.dom
	
	# 优化11：批量创建所有需要的ipset
	create_ipsets
	
	# 优化12：批量添加游戏模式IP
	batch_add_ips_to_ipset "gmlan" "$LAN_GM_IP"
	
	$ipt_n -N SS_SPEC_WAN_AC
	$ipt_n -I SS_SPEC_WAN_AC -p tcp ! --dport 53 -d $server -j RETURN
	
	if [ "$RUNMODE" = "router" ] || [ "$RUNMODE" = "gfw" ]; then
		ipset -! -R <<-EOF || return 1
		create ss_spec_wan_ac hash:net family inet
		$(gen_iplist | sed -e "s/^/add ss_spec_wan_ac /")
EOF
		
		# 优化13：检查并复制GFW配置文件
		if [ ! -f "/etc/storage/gfwlist/gfwlist_list.conf" ]; then
			mkdir -p /etc/storage/gfwlist
			cp -rf /etc_ro/gfwlist_list.conf /etc/storage/gfwlist/gfwlist_list.conf
		fi
		if [ ! -f "/tmp/dnsmasq.dom/gfwlist_list.conf" ]; then
			lua /etc_ro/ss/gfwcreate.lua
		fi
	fi
	
	# 优化14：使用函数生成模式规则
	mode_rules=$(generate_mode_rules "$RUNMODE")
	if [ -n "$mode_rules" ]; then
		echo "$mode_rules" | sh
	fi

	$ipt_n -I PREROUTING $SSNU -m comment --comment "$TAG" -j SS_SPEC_WAN_AC

	# 优化15：只在需要时读取配置文件并生成dnsmasq配置
	if [ -f "/etc/storage/ss_dom.sh" ]; then
		grep -v -E '^(!|$)' /etc/storage/ss_dom.sh | awk '{printf("server=/%s/127.0.0.1#5353\nipset=/%s/blacklist\n", $1, $1 )}' > /tmp/dnsmasq.dom/ss_dom.conf
	fi
	if [ -f "/etc/storage/uss_dom.sh" ]; then
		grep -v -E '^(!|$)' /etc/storage/uss_dom.sh | awk '{printf("ipset=/%s/whitelist\n", $1 )}' > /tmp/dnsmasq.dom/uss_dom.conf
	fi

	$ipt_n -I SS_SPEC_WAN_AC 2 -m set --match-set blacklist dst -j SS_SPEC_WAN_FW
	$ipt_n -I SS_SPEC_WAN_AC 2 -m set --match-set whitelist dst -j RETURN

	# 优化16：批量添加白名单和黑名单IP
	batch_add_ips_to_ipset "whitelist" "$WAN_BP_IP"
	batch_add_ips_to_ipset "blacklist" "$WAN_FW_IP"
	
	sed -i '/dnsmasq.dom/d' /etc/storage/dnsmasq/dnsmasq.conf
	cat >> /etc/storage/dnsmasq/dnsmasq.conf << EOF
conf-dir=/tmp/dnsmasq.dom/
EOF

	return $?
}

fw_rule() {
	# 优化17：构建防火墙规则的批量命令
	local fw_rules="$ipt_n -N SS_SPEC_WAN_FW"
	
	# 优化18：批量添加私有网络规则
	for network in $PRIVATE_NETWORKS; do
		fw_rules="${fw_rules}
$ipt_n -A SS_SPEC_WAN_FW -d $network -j RETURN"
	done
	
	echo $LANCON
	if [ "$LANCON" = "all" ] || [ "$LANCON" = "bip" ]; then
		batch_add_ips_to_ipset "fplan" "$LAN_FP_IP"
		
		if [ "$LANCON" = "all" ]; then
			fw_rules="${fw_rules}
$ipt_n -I SS_SPEC_WAN_FW -m set --match-set fplan src -j RETURN"
		else
			lanbip="-m set --match-set fplan src"
		fi
	fi

	# 优化19：一次性执行所有防火墙规则
	echo "$fw_rules" | sh

	$ipt_n -A SS_SPEC_WAN_FW -p tcp $PROXY_PORTS $lanbip \
		-j REDIRECT --to-ports $local_port 2>/dev/null || {
		loger 3 "Can't redirect, please check the iptables."
		exit 1
	}
	return $?
}

ac_rule() {
	if [ -n "$OUTPUT" ]; then
		$ipt_n -N SS_SPEC_WAN_DG
		$ipt_n -A SS_SPEC_WAN_DG -p tcp -j $OUTPUT
		$ipt_n -I OUTPUT 1 -p tcp -m comment --comment "$TAG" -j SS_SPEC_WAN_DG
		$ipt_n -I PREROUTING $(($SSNU+1)) -m comment --comment "$TAG" -j SS_SPEC_WAN_DG
	fi
	return $?
}

# 优化20：TPROXY规则生成器
generate_tproxy_rules() {
	local mode="$1"
	local rules=""
	
	case "$mode" in
	router)
		rules="$ipt_m -A SS_SPEC_TPROXY -p udp -m set --match-set ss_spec_wan_ac dst -j RETURN
$ipt_m -A SS_SPEC_TPROXY -p udp -m set --match-set china dst -j RETURN
$ipt_m -A SS_SPEC_TPROXY -p udp -m set --match-set gmlan src -m set ! --match-set china dst -j TPROXY --on-port \"$LOCAL_PORT\" --tproxy-mark 0x01/0x01
$ipt_m -A SS_SPEC_TPROXY -p udp $PROXY_PORTS -m set ! --match-set ss_spec_wan_ac dst -j TPROXY --on-port \"$LOCAL_PORT\" --tproxy-mark 0x01/0x01
$ipt_m -I SS_SPEC_TPROXY -p udp --dport 5353 -j RETURN"
		;;
	gfw)
		rules="$ipt_m -A SS_SPEC_TPROXY -p udp -m set --match-set china dst -j RETURN
$ipt_m -A SS_SPEC_TPROXY -p udp -m set $PROXY_PORTS --match-set gfwlist dst -j TPROXY --on-port \"$LOCAL_PORT\" --tproxy-mark 0x01/0x01
$ipt_m -A SS_SPEC_TPROXY -p udp -m set --match-set gmlan src -m set ! --match-set china dst -j TPROXY --on-port \"$LOCAL_PORT\" --tproxy-mark 0x01/0x01
$ipt_m -I SS_SPEC_TPROXY -p udp --dport 5353 -j RETURN"
		;;
	oversea)
		rules="$ipt_m -A SS_SPEC_TPROXY -p udp $PROXY_PORTS -m set --match-set oversea dst -j TPROXY --on-port \"$LOCAL_PORT\" --tproxy-mark 0x01/0x01
$ipt_m -A SS_SPEC_TPROXY -p udp -m set --match-set gmlan src -m set -j TPROXY --on-port \"$LOCAL_PORT\" --tproxy-mark 0x01/0x01
$ipt_m -A SS_SPEC_TPROXY -p udp $PROXY_PORTS -m set --match-set china dst -j TPROXY --on-port \"$LOCAL_PORT\" --tproxy-mark 0x01/0x01"
		;;
	all)
		rules="$ipt_m -A SS_SPEC_TPROXY -p udp $PROXY_PORTS -j TPROXY --on-port \"$LOCAL_PORT\" --tproxy-mark 0x01/0x01"
		;;
	esac
	
	echo "$rules"
}

tp_rule() {
	[ -n "$TPROXY" ] || return 0
	if !(lsmod | grep -q TPROXY ); then
		loger 4 "TPROXY or ip not found."
		logger -t "SS" "找不到TPROXY模块,UDP模式无法启用"
		return 0
	fi
	ip rule add fwmark 0x01/0x01 table 100
	ip route add local 0.0.0.0/0 dev lo table 100

	# 优化21：构建基础TPROXY规则
	local base_rules="$ipt_m -N SS_SPEC_TPROXY
$ipt_m -A SS_SPEC_TPROXY -p udp --dport 80 -j RETURN
$ipt_m -A SS_SPEC_TPROXY -p udp --dport 443 -j RETURN
$ipt_m -A SS_SPEC_TPROXY -p udp --dport 53 -j RETURN"

	# 优化22：批量添加私有网络RETURN规则
	for network in $PRIVATE_NETWORKS; do
		base_rules="${base_rules}
$ipt_m -A SS_SPEC_TPROXY -p udp -d $network -j RETURN"
	done
	
	base_rules="${base_rules}
$ipt_m -A SS_SPEC_TPROXY -p udp -d $SERVER -j RETURN"
	
	# 优化23：一次性执行基础规则
	echo "$base_rules" | sh
	
	if [ "$TPROXY" -ne 1 ]; then
		$ipt_n -I SS_SPEC_WAN_AC 1 -d $server -j RETURN
	fi

	# 优化24：使用函数生成TPROXY模式规则
	tproxy_rules=$(generate_tproxy_rules "$RUNMODE")
	if [ -n "$tproxy_rules" ]; then
		echo "$tproxy_rules" | sh
	fi
	
	$ipt_m -A PREROUTING -p udp -m comment --comment "$TAG" -j SS_SPEC_TPROXY
	$ipt_m -I SS_SPEC_TPROXY -p udp $PROXY_PORTS -m set --match-set blacklist dst \
	-j TPROXY --on-port "$LOCAL_PORT" --tproxy-mark 0x01/0x01
	$ipt_m -I SS_SPEC_TPROXY -p udp -m set --match-set whitelist dst -j RETURN

	return $?
}

get_wan_ip() {
	cat <<-EOF | grep -E "^([0-9]{1,3}\.){3}[0-9]{1,3}"
		$server
		$SERVER
		$WAN_BP_IP
EOF
}

gen_iplist() {
	cat <<-EOF
		0.0.0.0/8
		10.0.0.0/8
		100.64.0.0/10
		127.0.0.0/8
		169.254.0.0/16
		172.16.0.0/12
		192.0.0.0/24
		192.0.2.0/24
		192.88.99.0/24
		192.168.0.0/16
		198.18.0.0/15
		198.51.100.0/24
		203.0.113.0/24
		224.0.0.0/4
		240.0.0.0/4
		255.255.255.255
		$(get_wan_ip)
		$(cat ${IGNORE_LIST:=/dev/null} 2>/dev/null)
EOF
}

gen_spec_iplist() {
	cat <<-EOF
		0.0.0.0/8
		10.0.0.0/8
		100.64.0.0/10
		127.0.0.0/8
		169.254.0.0/16
		172.16.0.0/12
		192.0.0.0/24
		192.0.2.0/24
		192.88.99.0/24
		192.168.0.0/16
		198.18.0.0/15
		198.51.100.0/24
		203.0.113.0/24
		224.0.0.0/4
		240.0.0.0/4
		255.255.255.255
		$(get_wan_ip)
EOF
}

gen_include() {
	iptables-save | grep -E "SS_SPEC_|^\*|^COMMIT" | sed -e "s/^-A \(PREROUTING\)/-I \1 1/" > $FWI
	extract_rules() {
		echo "*$1"
		iptables-save -t $1 | grep SS_SPEC_ |\
			sed -e "s/^-A \(OUTPUT\|PREROUTING\)/-I \1 1/"
		echo 'COMMIT'
	}
	cat <<-EOF >>$FWI
	iptables-save -c | grep -v "SS_SPEC" | iptables-restore -c
	iptables-restore -n <<-EOT
	$(extract_rules nat)
	$(extract_rules mangle)
	EOT
EOF
	return 0
}

while getopts ":s:l:S:L:i:e:a:b:w:p:G:D:k:oOuUfgrczh" arg; do
	case "$arg" in
		s)
			server=$OPTARG
			;;
		l)
			local_port=$OPTARG
			;;
		S)
			SERVER=$OPTARG
			;;
		L)
			LOCAL_PORT=$OPTARG
			;;
		i)
			IGNORE_LIST=$OPTARG
			;;
		e)
			EXT_ARGS=$OPTARG
			;;
		a)
			LAN_AC_IP=$OPTARG
			;;
		b)
			WAN_BP_IP=$(while read ip; do echo $ip; done < $OPTARG)
			;;
		w)
			WAN_FW_IP=$(while read ip; do echo $ip; done < $OPTARG)
			;;
		p)
			LAN_FP_IP=$(while read ip; do echo $ip; done < $OPTARG)
			;;
		G)
			LAN_GM_IP=$(while read ip; do echo $ip; done < $OPTARG)
			;;
		D)
			PROXY_PORTS=$OPTARG
			;;
		o)
			OUTPUT=SS_SPEC_WAN_AC
			;;
		O)
			OUTPUT=SS_SPEC_WAN_FW
			;;
		u)
			TPROXY=1
			;;
		U)
			TPROXY=2
			;;
		g)
			RUNMODE=gfw
			;;
		r)
			RUNMODE=router
			;;
		c)
			RUNMODE=oversea
			;;
		z)
			RUNMODE=all
			;;
		k)
			LANCON=$OPTARG
			;;
		f)
			flush_r
			exit 0
			;;
		h)
			usage 0
			;;
	esac
done

if [ -z "$server" -o -z "$local_port" ]; then
	usage 2
fi

if [ "$TPROXY" = 1 ]; then
	SERVER=$server
	LOCAL_PORT=$local_port
elif [ "$TPROXY" = 2 ]; then
	: ${SERVER:?"You must assign an ip for the udp relay server."}
	: ${LOCAL_PORT:?"You must assign a port for the udp relay server."}
fi

flush_r && fw_rule && ipset_r && ac_rule && tp_rule && gen_include
[ "$?" = 0 ] || loger 3 "Start failed!"
exit $?

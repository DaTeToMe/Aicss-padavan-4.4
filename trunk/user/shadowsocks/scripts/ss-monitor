#!/bin/sh 

NAME=shadowsocksr
server_process_count=$1
redir_tcp_process=$2
redir_udp_process=$3
tunnel_process=$4
v2ray_process=$5
local_process=$6
pdnsd_process=$7
chinadnsng_process=0

# 优化1：缓存启动时的配置项，避免循环中重复nvram调用
cache_nvram_vars() {
    eval $(nvram show | grep -E '^(socks5_proxy_port|ss_cgroups|d_type|tunnel_forward)=' | sed 's/^/CACHED_/')
    
    sock5_port=$CACHED_socks5_proxy_port
    ss_cgroups_enabled=$CACHED_ss_cgroups
    d_type_cached=$CACHED_d_type
    tunnel_forward_cached=$CACHED_tunnel_forward
}

# 初始化缓存
cache_nvram_vars

# 优化2：缓存服务器IP解析，避免重复文件读取
if echo $server | grep -E "^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$" >/dev/null; then         
	server=${server}
else
	server=$(cat /etc/storage/ssr_ip)
fi

log() {
	logger -t "$NAME" "$@"
	echo "$(date "+%Y-%m-%d %H:%M:%S") $@" >> "/tmp/ssrplus.log"
}

run_bin() {
	(if [ "$ss_cgroups_enabled" = "1" ]; then
	 	echo 0 > /sys/fs/cgroup/cpu/$NAME/tasks
	 	echo 0 > /sys/fs/cgroup/memory/$NAME/tasks
		limit_bytes="$(cat /sys/fs/cgroup/memory/$NAME/memory.limit_in_bytes)"
		[ -n "$limit_bytes" ] && export GOMEMLIMIT="$limit_bytes"
	 fi
	 "$@" > /dev/null 2>&1
	) &
}

stop_dns_proxy() {
	pgrep dns2tcp | args kill
	pgrep dnsproxy | args kill	
}

start_dns_proxy() {
	if [ $pdnsd_process = 1 ]; then
		dns2tcp -L"127.0.0.1#5353" -R"$tunnel_forward_cached" >/dev/null 2>&1 &
	elif [ $pdnsd_process = 0 ]; then
		remote_ip=$(echo "$tunnel_forward_cached" | awk -F '#' '{print $1}')
		dnsproxy -d -p 5353 -R $remote_ip >/dev/null 2>&1 &
	else
		log "DNS解析方式不支持该选项: $pdnsd_process , 建议选择dnsproxy"
	fi
}

# 优化3：统一的进程检查函数，一次性获取所有进程信息
get_all_process_counts() {
    # 一次性获取所有相关进程信息，减少系统调用
    local ps_output=$(ps -w | grep -E "(ssr-retcp|ssr-reudp|ssr-server|$d_type_cached|ssr-local|dnsproxy|dns2tcp)" | grep -v grep)
    
    retcp_count=$(echo "$ps_output" | grep -c "ssr-retcp")
    reudp_count=$(echo "$ps_output" | grep -c "ssr-reudp")
    current_server_count=$(echo "$ps_output" | grep -c "ssr-server")
    v2ray_count=$(echo "$ps_output" | grep -c "$d_type_cached")
    current_local_count=$(echo "$ps_output" | grep -c "ssr-local")
    dnsproxy_count=$(echo "$ps_output" | grep -c "dnsproxy")
    dns2tcp_count=$(echo "$ps_output" | grep -c "dns2tcp")
}

while [ "1" = "1" ]
do 
	sleep 10
	
	# 优化4：使用统一函数获取所有进程计数，减少重复的ps调用
	get_all_process_counts
	
	# redir tcp
	if [ $redir_tcp_process -gt 0 ]; then
		if [ $retcp_count = 0 ]; then
			log "检测到 SS 进程挂掉，正在重启..."
			/usr/bin/shadowsocks.sh restart 
			exit 0
		fi
	fi
	
	# redir udp
	if [ $redir_udp_process -gt 0 ]; then
		if [ $reudp_count = 0 ]; then
			log "检测到 SS 进程挂掉，正在重启..."
			/usr/bin/shadowsocks.sh restart  
			exit 0
		fi
	fi
	
	# server
	if [ $server_process_count -gt 0 ]; then
		if [ $current_server_count -lt $server_process_count ]; then
			log "ssr server error.restart!"
			killall -q -9 ssr-server 
			for i in $(seq $server_process_count); do
				run_bin /usr/bin/ssr-server -c /tmp/shadowsocksr_$i.json -u -f /tmp/ssr-server$i.pid   
			done
		fi
	fi
	
	# V2RAY/XRAY/TROJAN
	if [ $v2ray_process -gt 0 ]; then
		bin="$d_type_cached"
		conf="/tmp/v2-redir.json"
		[ ! -f "/usr/bin/$bin" ] && bin=$(echo -e "v2ray\nxray" | grep -v $bin)
		[ "$bin" = "trojan" ] && conf="/tmp/tj-redir.json"
		if [ $v2ray_count -lt $v2ray_process ]; then
			log "检测到 $bin 进程挂掉，正在重启..."
			killall -q -9 $bin
			run_bin /usr/bin/$bin --config $conf
		fi
	fi
	
	# local
	if [ $local_process -gt 0 ]; then
		if [ $current_local_count -lt $local_process ]; then
			log "ssr local error.restart!"
			/usr/bin/shadowsocks.sh restart
			exit 0
		fi
	fi
	
	# dnsproxy
	if [ $pdnsd_process = 0 ]; then
		if [ $dnsproxy_count = 0 ]; then
			log "dnsproxy is restarted!"
			stop_dns_proxy
			start_dns_proxy
		fi
	fi
	
	# dns2tcp
	if [ $pdnsd_process = 1 ]; then
		if [ $dns2tcp_count = 0 ]; then
			log "dns2tcp is restarted!"
			stop_dns_proxy
			start_dns_proxy
		fi
	fi
	
	# chinadns-ng（已禁用，保持原有结构完全不变）
	# if [ $chinadnsng_process -gt 0 ] ;then
	# 	icount=`ps -w | grep chinadns-ng | grep -v grep | wc -l`
	# 	if [ $icount -lt $chinadnsng_process ]  #如果进程挂掉就重启它
	# 	then
	# 		log "chinadns-ng tunnel error.restart!"
	# 		kill -9 chinadns-ng
	# 		stop_dns_proxy
	# 		start_dns_proxy
	# 		local_chnlist_file='/etc/storage/chinadns/chnlist_mini.txt'
	# 		if [ -f "$local_chnlist_file" ]; then
	# 		  log "启动chinadns分流，仅国外域名走DNS代理..."
	# 		  chinadns-ng -b 0.0.0.0 -l 65353 -c $(nvram get china_dns) -t 127.0.0.1#5353 -4 china -M -m $local_chnlist_file >/dev/null 2>&1 &
	# 		else
	# 		  log "启动chinadns分流，全部域名走DNS代理...本次不使用本地cdn域名文件$local_chnlist_file, 下次你自已可以创建它，文件中每行表示一个域名（不用要子域名）"
	# 		  chinadns-ng -b 0.0.0.0 -l 65353 -c $(nvram get china_dns) -t 127.0.0.1#5353 -4 china >/dev/null 2>&1 &
	# 		fi
	# 		sed -i '/no-resolv/d' /etc/storage/dnsmasq/dnsmasq.conf
	# 		sed -i '/server=127.0.0.1/d' /etc/storage/dnsmasq/dnsmasq.conf
	# 		cat >> /etc/storage/dnsmasq/dnsmasq.conf << EOF
	# no-resolv
	# server=127.0.0.1#65353
	# EOF
	# 	fi
	# fi
done

#!/bin/sh 

NAME=shadowsocksr

# 修复：支持从文件读取参数，保持向后兼容
if [ -f /tmp/ss-monitor-params.conf ]; then
    # 从参数文件读取（优先）
    . /tmp/ss-monitor-params.conf
else
    # 从命令行参数读取（兼容旧版本）
    server_process_count=$1
    redir_tcp_process=$2
    redir_udp_process=$3
    tunnel_process=$4
    v2ray_process=$5
    local_process=$6
    pdnsd_process=$7
fi
chinadnsng_process=0

# 监控和重启控制参数
CHECK_INTERVAL=30         # 进程检查间隔（秒）
RESTART_COOLDOWN=60      # 重启冷却时间120秒
MAX_RESTART_COUNT=8       # 最大连续重启次数
RESET_COUNT_INTERVAL=300  # 5分钟后重置重启计数
STARTUP_WAIT_TIME=60      # 进程启动等待时间
DOUBLE_CHECK_INTERVAL=30  # 二次确认间隔

# 状态文件路径（用于状态持久化）
STATE_DIR="/tmp/ss-monitor-state"
RESTART_COUNT_FILE="$STATE_DIR/restart_count"
LAST_RESTART_FILE="$STATE_DIR/last_restart"

# 初始化状态目录
mkdir -p "$STATE_DIR"

# 读取持久化状态
load_state() {
    if [ -f "$RESTART_COUNT_FILE" ]; then
        restart_count=$(cat "$RESTART_COUNT_FILE")
    else
        restart_count=0
    fi
    
    if [ -f "$LAST_RESTART_FILE" ]; then
        last_restart_time=$(cat "$LAST_RESTART_FILE")
    else
        last_restart_time=0
    fi
}

# 保存状态
save_state() {
    echo "$restart_count" > "$RESTART_COUNT_FILE"
    echo "$last_restart_time" > "$LAST_RESTART_FILE"
}

# 优化1：改进的nvram缓存函数，增加容错性和默认值
cache_nvram_vars() {
    # 安全地获取nvram变量，如果失败则使用默认值
    local nvram_output
    nvram_output=$(nvram show 2>/dev/null | grep -E '^(socks5_proxy_port|ss_cgroups|d_type|tunnel_forward)=' || true)
    
    if [ -n "$nvram_output" ]; then
        eval $(echo "$nvram_output" | sed 's/^/CACHED_/')
    fi
    
    # 设置变量，如果缓存失败则使用默认值
    sock5_port=${CACHED_socks5_proxy_port:-"1080"}
    ss_cgroups_enabled=${CACHED_ss_cgroups:-"0"}
    d_type_cached=${CACHED_d_type:-"ss"}
    tunnel_forward_cached=${CACHED_tunnel_forward:-"8.8.8.8#53"}
}

# 初始化缓存和状态
cache_nvram_vars
load_state

log() {
	logger -t "$NAME" "$@"
	echo "$(date "+%Y-%m-%d %H:%M:%S") $@" >> "/tmp/ssrplus.log"
}

run_bin() {
	(if [ "$ss_cgroups_enabled" = "1" ]; then
	 	echo 0 > /sys/fs/cgroup/cpu/$NAME/tasks
	 	echo 0 > /sys/fs/cgroup/memory/$NAME/tasks
		limit_bytes="$(cat /sys/fs/cgroup/memory/$NAME/memory.limit_in_bytes)"
		[ -n "$limit_bytes" ] && export GOMEMLIMIT="$limit_bytes"
	 fi
	 "$@" > /dev/null 2>&1
	) &
}

stop_dns_proxy() {
	pgrep dns2tcp | xargs kill 2>/dev/null || true
	pgrep dnsproxy | xargs kill 2>/dev/null || true
}

start_dns_proxy() {
	if [ $pdnsd_process = 1 ]; then
		dns2tcp -L"127.0.0.1#5353" -R"$tunnel_forward_cached" >/dev/null 2>&1 &
	elif [ $pdnsd_process = 0 ]; then
		remote_ip=$(echo "$tunnel_forward_cached" | awk -F '#' '{print $1}')
		dnsproxy -d -p 5353 -R $remote_ip >/dev/null 2>&1 &
	else
		log "DNS解析方式不支持该选项: $pdnsd_process , 建议选择dnsproxy"
	fi
}

# 优化2：改进的进程检查函数，增加变量有效性检查
get_all_process_counts() {
    # 构建安全的grep模式，确保d_type_cached不为空
    local grep_pattern="(ssr-retcp|ssr-reudp|ssr-server|ssr-local|dnsproxy|dns2tcp"
    if [ -n "$d_type_cached" ] && [ "$d_type_cached" != "ss" ] && [ "$d_type_cached" != "ssr" ]; then
        grep_pattern="${grep_pattern}|${d_type_cached}"
    fi
    grep_pattern="${grep_pattern})"
    
    # 一次性获取所有相关进程信息，减少系统调用
    local ps_output=$(ps -w | grep -E "$grep_pattern" | grep -v grep)
    
    retcp_count=$(echo "$ps_output" | grep -c "ssr-retcp" || echo "0")
    reudp_count=$(echo "$ps_output" | grep -c "ssr-reudp" || echo "0")
    current_server_count=$(echo "$ps_output" | grep -c "ssr-server" || echo "0")
    current_local_count=$(echo "$ps_output" | grep -c "ssr-local" || echo "0")
    dnsproxy_count=$(echo "$ps_output" | grep -c "dnsproxy" || echo "0")
    dns2tcp_count=$(echo "$ps_output" | grep -c "dns2tcp" || echo "0")
    
    # 安全地计算v2ray/xray/trojan进程数
    if [ -n "$d_type_cached" ] && [ "$d_type_cached" != "ss" ] && [ "$d_type_cached" != "ssr" ]; then
        v2ray_count=$(echo "$ps_output" | grep -c "$d_type_cached" || echo "0")
    else
        v2ray_count=0
    fi
}

# 重启控制函数
can_restart() {
    local current_time=$(date +%s)
    local time_diff=$((current_time - last_restart_time))
    
    # 检查是否在冷却期内
    if [ $time_diff -lt $RESTART_COOLDOWN ]; then
        log "在重启冷却期内，跳过重启 (剩余 $((RESTART_COOLDOWN - time_diff)) 秒)"
        return 1
    fi
    
    # 检查重启次数
    if [ $restart_count -ge $MAX_RESTART_COUNT ]; then
        log "重启次数已达上限 ($MAX_RESTART_COUNT)，停止自动重启。请检查配置或手动处理。"
        return 1
    fi
    
    return 0
}

# 重置重启计数
reset_restart_count_if_needed() {
    local current_time=$(date +%s)
    local time_diff=$((current_time - last_restart_time))
    
    # 如果距离上次重启超过重置间隔，重置计数
    if [ $time_diff -gt $RESET_COUNT_INTERVAL ] && [ $restart_count -gt 0 ]; then
        restart_count=0
        save_state
        log "系统稳定运行，重启计数已重置"
    fi
}

# 统一的重启函数
safe_restart_service() {
    local reason="$1"
    
    if ! can_restart; then
        return 1
    fi
    
    log "检测到问题：$reason，准备重启服务 (第 $((restart_count + 1)) 次)"
    
    # 更新重启记录
    restart_count=$((restart_count + 1))
    last_restart_time=$(date +%s)
    save_state
    
    # 修复：使用restart命令，依赖shadowsocks.sh中的清理逻辑避免多实例
    # restart会杀死当前ss-monitor，但shadowsocks.sh会启动新的监控实例
    /usr/bin/shadowsocks.sh restart
    
    # 注意：以下代码不会执行，因为当前进程会被restart杀死
    # 这是正常的，新的ss-monitor实例会接管监控工作
    exit 0
}

# 二次确认函数
double_check_process_status() {
    log "检测到进程异常，等待 $DOUBLE_CHECK_INTERVAL 秒后进行二次确认..."
    sleep $DOUBLE_CHECK_INTERVAL
    get_all_process_counts
}

# 简单的端口连通性检查
check_proxy_port() {
    local port=$1
    local service_name=$2
    
    # 使用nc命令检查端口是否可访问
    nc -z -w 2 127.0.0.1 $port >/dev/null 2>&1
    if [ $? -ne 0 ]; then
        log "$service_name 端口 $port 无响应"
        return 1
    fi
    return 0
}

while [ "1" = "1" ]
do 
	sleep $CHECK_INTERVAL
	
	# 修复：重新读取参数文件（如果存在），支持动态配置更新
	if [ -f /tmp/ss-monitor-params.conf ]; then
		. /tmp/ss-monitor-params.conf
	fi
	
	# 重置重启计数
	reset_restart_count_if_needed
	
	# 优化3：使用改进的统一函数获取所有进程计数
	get_all_process_counts
	
	# 检查是否需要重启服务的标志
	need_service_restart=0
	restart_reason=""
	
	# redir tcp
	if [ $redir_tcp_process -gt 0 ]; then
		if [ $retcp_count = 0 ]; then
			need_service_restart=1
			restart_reason="TCP重定向进程异常"
		else
			# 进程存在时检查端口连通性
			if ! check_proxy_port 1080 "TCP代理"; then
				need_service_restart=1
				restart_reason="${restart_reason:+$restart_reason, }TCP代理端口无响应"
			fi
		fi
	fi
	
	# redir udp
	if [ $redir_udp_process -gt 0 ]; then
		if [ $reudp_count = 0 ]; then
			need_service_restart=1
			restart_reason="${restart_reason:+$restart_reason, }UDP重定向进程异常"
		fi
	fi
	
	# local
	if [ $local_process -gt 0 ]; then
		if [ $current_local_count -lt $local_process ]; then
			need_service_restart=1
			restart_reason="${restart_reason:+$restart_reason, }本地SOCKS5进程异常"
		else
			# 进程存在时检查SOCKS5端口（如果配置了）
			if [ -n "$sock5_port" ] && [ "$sock5_port" != "0" ]; then
				if ! check_proxy_port $sock5_port "SOCKS5代理"; then
					need_service_restart=1
					restart_reason="${restart_reason:+$restart_reason, }SOCKS5端口无响应"
				fi
			fi
		fi
	fi
	
	# 统一处理需要完整重启的情况
	if [ $need_service_restart = 1 ]; then
		double_check_process_status
		
		# 重新检查状态
		need_service_restart=0
		if [ $redir_tcp_process -gt 0 ]; then
			if [ $retcp_count = 0 ]; then
				need_service_restart=1
			elif ! check_proxy_port 1080 "TCP代理"; then
				need_service_restart=1
			fi
		fi
		if [ $redir_udp_process -gt 0 ] && [ $reudp_count = 0 ]; then
			need_service_restart=1
		fi
		if [ $local_process -gt 0 ]; then
			if [ $current_local_count -lt $local_process ]; then
				need_service_restart=1
			elif [ -n "$sock5_port" ] && [ "$sock5_port" != "0" ]; then
				if ! check_proxy_port $sock5_port "SOCKS5代理"; then
					need_service_restart=1
				fi
			fi
		fi
		
		if [ $need_service_restart = 1 ]; then
			safe_restart_service "$restart_reason"
		else
			log "二次确认后进程状态正常，可能是短暂异常"
		fi
	fi
	
	# server - 独立重启逻辑
	if [ $server_process_count -gt 0 ]; then
		if [ $current_server_count -lt $server_process_count ]; then
			log "ssr server进程数不足，当前: $current_server_count, 期望: $server_process_count"
			killall -q -9 ssr-server 
			for i in $(seq $server_process_count); do
				run_bin /usr/bin/ssr-server -c /tmp/shadowsocksr_$i.json -u -f /tmp/ssr-server$i.pid   
			done
			log "ssr server进程已重启"
		fi
	fi
	
	# V2RAY/XRAY/TROJAN - 独立重启逻辑
	if [ $v2ray_process -gt 0 ]; then
		bin="$d_type_cached"
		conf="/tmp/v2-redir.json"
		[ ! -f "/usr/bin/$bin" ] && bin=$(echo -e "v2ray\nxray" | grep -v $bin)
		[ "$bin" = "trojan" ] && conf="/tmp/tj-redir.json"
		if [ $v2ray_count -lt $v2ray_process ]; then
			log "检测到 $bin 进程异常，当前: $v2ray_count, 期望: $v2ray_process"
			killall -q -9 $bin
			run_bin /usr/bin/$bin --config $conf
			log "$bin 进程已重启"
		fi
	fi
	
	# dnsproxy - 独立重启逻辑
	if [ $pdnsd_process = 0 ]; then
		if [ $dnsproxy_count = 0 ]; then
			log "dnsproxy进程异常，正在重启"
			stop_dns_proxy
			start_dns_proxy
		fi
	fi
	
	# dns2tcp - 独立重启逻辑
	if [ $pdnsd_process = 1 ]; then
		if [ $dns2tcp_count = 0 ]; then
			log "dns2tcp进程异常，正在重启"
			stop_dns_proxy
			start_dns_proxy
		fi
	fi
	
	# chinadns-ng（已禁用，保持原有结构完全不变）
	# if [ $chinadnsng_process -gt 0 ] ;then
	# 	icount=`ps -w | grep chinadns-ng | grep -v grep | wc -l`
	# 	if [ $icount -lt $chinadnsng_process ]  #如果进程挂掉就重启它
	# 	then
	# 		log "chinadns-ng tunnel error.restart!"
	# 		kill -9 chinadns-ng
	# 		stop_dns_proxy
	# 		start_dns_proxy
	# 		local_chnlist_file='/etc/storage/chinadns/chnlist_mini.txt'
	# 		if [ -f "$local_chnlist_file" ]; then
	# 		  log "启动chinadns分流，仅国外域名走DNS代理..."
	# 		  chinadns-ng -b 0.0.0.0 -l 65353 -c $(nvram get china_dns) -t 127.0.0.1#5353 -4 china -M -m $local_chnlist_file >/dev/null 2>&1 &
	# 		else
	# 		  log "启动chinadns分流，全部域名走DNS代理...本次不使用本地cdn域名文件$local_chnlist_file, 下次你自已可以创建它，文件中每行表示一个域名（不用要子域名）"
	# 		  chinadns-ng -b 0.0.0.0 -l 65353 -c $(nvram get china_dns) -t 127.0.0.1#5353 -4 china >/dev/null 2>&1 &
	# 		fi
	# 		sed -i '/no-resolv/d' /etc/storage/dnsmasq/dnsmasq.conf
	# 		sed -i '/server=127.0.0.1/d' /etc/storage/dnsmasq/dnsmasq.conf
	# 		cat >> /etc/storage/dnsmasq/dnsmasq.conf << EOF
	# no-resolv
	# server=127.0.0.1#65353
	# EOF
	# 	fi
	# fi
done
